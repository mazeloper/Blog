---
description: >-
  Koin은 입사 후 이전 퇴사자가 사용한 것을 참고하여 새로운 프로젝트에 적용하였지만 사실 제대로 알고 사용하지못했다. 해당 글을 작성하면서
  나 또한 열심히 알아볼 예정이다 😱
---

# Koin

![https://insert-koin.io/](https://insert-koin.io/img/koin\_new\_logo.png)

### DI (Dependency injection / 의존성 주입) 이란?

Koin 에 대해 알아보기 전에 DI 에 무엇인지 알아야 한다.

우선 안드로이드 DI 를 적용하면 훌륭한 앱 아키텍처를 위한 토대를 마련할 수 있다.\
안드로이드 공식문서에 따르면 DI 를 적용하면 아래와 같은 이점이 누릴 수 있다.

* 코드 재사용 가능
* 리팩토링 편의성
* 테스트 편의성

~~이 글을 작성하면서 나 스스로 위에 이점들을 잘 누리고 있었는지 되돌아 볼 것이다.~~

****

우선 클래스에는 다른 클래스 참조가 필요하다. 예를 들어 `Car` 클래스는 `Engine` 클래스 참조가 필요할 수 있다.\
이처럼 필요한 클래스를 종속 항목(_dependencies) 이라고 하며, `Car` 클래스가 실행되기 위해서는 `Engine` 클래스의 인스턴스가 필요하다._

_클래스가 필요한 객체를 얻는 방법은 3가지가 있다._

* 클래스가 필요한 종속 항목 (Engine Class) 을 구성한다. 위 예에서는 Car 클래스는 자체 Engine 인스턴스를 생성하여 초기화한다.
* 다른 곳에서 객체를 가져온다. `Context` getter & `getSystemService`() 와 같은 일부 Android API는 여러한 방식으로 작동한다.
* 객체를 매게변수로 제공받는다. 앱은 클래스가 구성될 때 이러한 종속 항목을 제공하거나 각 종속 항목이 필요한 함수에 전달할 수 있다. 위 예에서는 Car 생성자는 Engine 을 매개변수로 받는다.

**여기서 말하는 3번째 방법이 바로 DI / 의존성주입이다** 🔥\
__이 방법을 사용하면 클래스 인스턴스가 자체적으로 종속 항목을 얻는 대신 클래스의 종속 항목을 받아서 제공한다.

우선 1번과 같은 방법으로 인스턴스화 하는거는 아래 코드와 같다.

```kotlin
class Car {

    private val engine = Engine()

    fun start() {
        engine.start()
    }
}

class Engine {
    fun start() {
        // write code...
    }
}
```

이 예는 Car 클래스가 자체 Engine 을 객체생성 후 사용하기 때문에 DI 가 아니다. 또한 아래와 같은 문제가 발생할 수 있다.

* Car 와 Engine 은 밀접하게 연결되어있다. Car 인스턴스는 한 가지 유형의 Engine 을 사용하므로 서브클래스 또는 대체 구현을 쉽게 사용할 수 없다.
